<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpertScheduleController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mentara-server</a> &gt; <a href="index.source.html" class="el_package">com.mentara.controller</a> &gt; <span class="el_source">ExpertScheduleController.java</span></div><h1>ExpertScheduleController.java</h1><pre class="source lang-java linenums">package com.mentara.controller;

import com.mentara.service.ExpertScheduleService;
import com.mentara.service.UserService;
import com.mentara.service.impl.ExpertScheduleServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.HashMap;
import java.util.Optional;
import java.util.List;
import com.mentara.entity.User;
import com.mentara.entity.Expert;
import com.mentara.repository.ExpertRepository;


@RestController
@RequestMapping(&quot;/expert-schedule&quot;)
<span class="fc" id="L22">@RequiredArgsConstructor</span>
public class ExpertScheduleController {

    private final ExpertScheduleService expertScheduleService;
    private final UserService userService;
    private final ExpertRepository expertRepository;

    /**
     * 获取专家的可预约时段（公开接口，所有登录用户可访问）
     */
    @GetMapping(&quot;/{expertId}/slots&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public boolean[][] getAvailableSlots(@PathVariable Long expertId) {
<span class="fc" id="L35">        return expertScheduleService.getAvailableSlots(expertId);</span>
    }

    /**
     * 通过用户ID获取专家的可预约时段（公开接口，所有登录用户可访问）
     */
    @GetMapping(&quot;/user/{userId}/slots&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public boolean[][] getAvailableSlotsByUserId(@PathVariable Long userId) {
<span class="fc" id="L44">        return expertScheduleService.getAvailableSlotsByUserId(userId);</span>
    }

    /**
     * 获取专家的详细时间表状态（包含预约占用信息）
     */
    @GetMapping(&quot;/{expertId}/detailed-slots&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public int[][] getDetailedSlots(@PathVariable Long expertId) {
<span class="fc" id="L53">        return expertScheduleService.getDetailedSlots(expertId);</span>
    }

    /**
     * 通过用户ID获取专家的详细时间表状态（包含预约占用信息）
     */
    @GetMapping(&quot;/user/{userId}/detailed-slots&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public int[][] getDetailedSlotsByUserId(@PathVariable Long userId) {
        try {
<span class="nc" id="L63">            return expertScheduleService.getDetailedSlotsByUserId(userId);</span>
<span class="fc" id="L64">        } catch (Exception e) {</span>
            // 如果获取详细状态失败，返回一个基础的可用状态矩阵
            // 这样前端不会完全破坏，虽然没有预约占用信息
<span class="fc" id="L67">            int[][] fallbackSlots = new int[14][8];</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            for (int day = 0; day &lt; 14; day++) {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">                for (int period = 0; period &lt; 8; period++) {</span>
<span class="fc" id="L70">                    fallbackSlots[day][period] = 1; // 默认所有时段可用</span>
                }
            }
<span class="fc" id="L73">            return fallbackSlots;</span>
        }
    }

    /**
     * 测试端点：验证用户是否为专家以及关联的Expert记录
     */
    @GetMapping(&quot;/user/{userId}/debug&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public Map&lt;String, Object&gt; debugUserExpertInfo(@PathVariable Long userId) {
<span class="fc" id="L83">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>
        try {
            // 检查用户是否存在
<span class="fc" id="L86">            Optional&lt;User&gt; userOpt = userService.findById(userId);</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            if (!userOpt.isPresent()) {</span>
<span class="nc" id="L88">                result.put(&quot;error&quot;, &quot;用户不存在&quot;);</span>
<span class="nc" id="L89">                return result;</span>
            }
            
<span class="fc" id="L92">            User user = userOpt.get();</span>
<span class="fc" id="L93">            result.put(&quot;userId&quot;, userId);</span>
<span class="fc" id="L94">            result.put(&quot;username&quot;, user.getUsername());</span>
<span class="fc" id="L95">            result.put(&quot;role&quot;, user.getRole().toString());</span>
<span class="fc" id="L96">            result.put(&quot;isExpert&quot;, user.isExpert());</span>
            
            // 检查是否有Expert记录
<span class="fc" id="L99">            Optional&lt;Expert&gt; expertOpt = expertRepository.findByUserId(userId);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (expertOpt.isPresent()) {</span>
<span class="fc" id="L101">                Expert expert = expertOpt.get();</span>
<span class="fc" id="L102">                result.put(&quot;expertId&quot;, expert.getId());</span>
<span class="fc" id="L103">                result.put(&quot;expertName&quot;, expert.getName());</span>
<span class="fc" id="L104">                result.put(&quot;expertSpecialty&quot;, expert.getSpecialty());</span>
<span class="fc" id="L105">                result.put(&quot;expertStatus&quot;, expert.getStatus());</span>
<span class="fc" id="L106">            } else {</span>
<span class="fc" id="L107">                result.put(&quot;expertRecord&quot;, &quot;不存在&quot;);</span>
            }
            
<span class="fc" id="L110">            return result;</span>
<span class="nc" id="L111">        } catch (Exception e) {</span>
<span class="nc" id="L112">            result.put(&quot;error&quot;, e.getMessage());</span>
<span class="nc" id="L113">            return result;</span>
        }
    }

    /**
     * 获取专家的排班信息（管理员或专家本人）
     */
    @GetMapping(&quot;/{expertId}/schedule&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or @expertScheduleService.isExpertOwner(#expertId, authentication)&quot;)
    public Map&lt;String, Object&gt; getExpertSchedule(@PathVariable Long expertId) {
<span class="fc" id="L123">        return expertScheduleService.getExpertSchedule(expertId);</span>
    }

    /**
     * 获取当前专家的排班信息
     */
    @GetMapping(&quot;/schedule&quot;)
    @PreAuthorize(&quot;hasRole('EXPERT')&quot;)
    public Map&lt;String, Object&gt; getMyExpertSchedule(Authentication authentication) {
<span class="fc" id="L132">        String username = authentication.getName();</span>
<span class="fc" id="L133">        Long userId = userService.findByUsername(username)</span>
<span class="pc" id="L134">                .orElseThrow(() -&gt; new RuntimeException(&quot;用户不存在: &quot; + username))</span>
<span class="fc" id="L135">                .getId();</span>
<span class="fc" id="L136">        return expertScheduleService.getExpertScheduleByUserId(userId);</span>
    }

    /**
     * 更新专家的排班信息（管理员或专家本人）
     */
    @PutMapping(&quot;/{expertId}/update&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or @expertScheduleService.isExpertOwner(#expertId, authentication)&quot;)
    public boolean updateSchedule(@PathVariable Long expertId,
                                 @RequestParam int dayOffset,
                                 @RequestParam int periodIndex,
                                 @RequestParam boolean available) {
<span class="fc" id="L148">        return expertScheduleService.updateExpertAvailability(expertId, dayOffset, periodIndex, available);</span>
    }

    /**
     * 更新当前专家用户的排班信息
     */
    @PutMapping(&quot;/update&quot;)
    @PreAuthorize(&quot;hasRole('EXPERT')&quot;)
    public boolean updateMySchedule(Authentication authentication,
                                   @RequestParam int dayOffset,
                                   @RequestParam int periodIndex,
                                   @RequestParam boolean available) {
<span class="fc" id="L160">        String username = authentication.getName();</span>
<span class="fc" id="L161">        Long userId = userService.findByUsername(username)</span>
<span class="pc" id="L162">                .orElseThrow(() -&gt; new RuntimeException(&quot;用户不存在: &quot; + username))</span>
<span class="fc" id="L163">                .getId();</span>
<span class="fc" id="L164">        return expertScheduleService.updateExpertAvailabilityByUserId(userId, dayOffset, periodIndex, available);</span>
    }

    /**
     * 批量更新当前专家用户的排班信息
     */
    @PutMapping(&quot;/batch-update&quot;)
    @PreAuthorize(&quot;hasRole('EXPERT')&quot;)
    public Map&lt;String, Object&gt; batchUpdateMySchedule(Authentication authentication,
                                                   @RequestBody List&lt;ScheduleUpdateRequest&gt; updates) {
<span class="fc" id="L174">        String username = authentication.getName();</span>
<span class="fc" id="L175">        Long userId = userService.findByUsername(username)</span>
<span class="pc" id="L176">                .orElseThrow(() -&gt; new RuntimeException(&quot;用户不存在: &quot; + username))</span>
<span class="fc" id="L177">                .getId();</span>
        
<span class="fc" id="L179">        int successCount = expertScheduleService.batchUpdateExpertAvailabilityByUserId(userId, updates);</span>
        
<span class="fc" id="L181">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L182">        result.put(&quot;success&quot;, true);</span>
<span class="fc" id="L183">        result.put(&quot;totalRequests&quot;, updates.size());</span>
<span class="fc" id="L184">        result.put(&quot;successCount&quot;, successCount);</span>
<span class="fc" id="L185">        return result;</span>
    }

    /**
     * 排班更新请求DTO
     */
<span class="fc" id="L191">    public static class ScheduleUpdateRequest {</span>
        private int dayOffset;
        private int periodIndex;
        private boolean available;
        
        // Getters and setters
<span class="fc" id="L197">        public int getDayOffset() { return dayOffset; }</span>
<span class="fc" id="L198">        public void setDayOffset(int dayOffset) { this.dayOffset = dayOffset; }</span>
        
<span class="fc" id="L200">        public int getPeriodIndex() { return periodIndex; }</span>
<span class="fc" id="L201">        public void setPeriodIndex(int periodIndex) { this.periodIndex = periodIndex; }</span>
        
<span class="fc" id="L203">        public boolean isAvailable() { return available; }</span>
<span class="fc" id="L204">        public void setAvailable(boolean available) { this.available = available; }</span>
    }

    /**
     * 数据迁移端点：将旧格式数据迁移到新的状态格式
     * 只在系统升级时使用一次
     */
    @PostMapping(&quot;/migrate-data&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)
    public String migrateScheduleData() {
        try {
<span class="fc" id="L215">            ((ExpertScheduleServiceImpl) expertScheduleService).migrateScheduleDataFormat();</span>
<span class="fc" id="L216">            return &quot;数据迁移完成&quot;;</span>
<span class="nc" id="L217">        } catch (Exception e) {</span>
<span class="nc" id="L218">            return &quot;数据迁移失败: &quot; + e.getMessage();</span>
        }
    }
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>